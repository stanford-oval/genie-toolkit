// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//         Giovanni Campagna <gcampagn@cs.stanford.edu>

import assert from 'assert';
import { Ast, Type } from 'thingtalk';

import * as C from '../ast_manip';
import ThingpediaLoader from '../load-thingpedia';

{
const HERE = new Ast.Value.Location(new Ast.Location.Relative('current_location'));
}

// generic filters (npp)
get_predicate_filter : C.DomainIndependentFilterSlot = {
    'before' t1:constant_Time => C.timeGetPredicate($loader, null, t1);
    'after' t2:constant_Time  => C.timeGetPredicate($loader, t2, null);
    'between' t1:constant_Time 'and' t2:constant_Time => C.timeGetPredicate($loader, t1, t2);

    'my location is' loc:constant_Location     => C.locationGetPredicate($loader, loc);
    'my location is not' loc:constant_Location => C.locationGetPredicate($loader, loc, true);
    'i am at' loc:constant_Location            => C.locationGetPredicate($loader, loc);
    'i am not at' loc:constant_Location        => C.locationGetPredicate($loader, loc, true);

    proj:projection_Any ('is' | 'is exactly' | 'is equal to') x:constant_Any        => C.makeGetPredicate(proj, '==', x);
    proj:projection_Any ('is not' | 'is n\'t' | 'is different than') x:constant_Any => C.makeGetPredicate(proj, '==', x, true);
}

if_filter : C.FilterSlot|C.DomainIndependentFilterSlot = {
    ?get_predicate get_predicate_filter;

    // note: we cannot apply a type constraint here because type equality would not
    // work with enums (which have incomplete type at the Ast.Value) and entities
    // makeFilter has the right logic to check types
    'the' p:out_param_Any ('is' | 'is exactly' | 'is equal to') x:constant_Any => C.makeFilter($loader, p, '==', x);
    'the' p:out_param_Any ('is' | 'is exactly' | 'is equal to') x:constant_Any => C.makeFilter($loader, p, '==', x);

    'the' p:out_param_Any ('is not' | 'is n\'t' | 'is different than') x:constant_Any with { type = p.type } => C.makeFilter($loader, p, '==', x, true);

    //p:the_out_param_Numeric 'is' ('greater' | 'higher' | 'bigger' | 'more' | 'at least' | 'not less than') x:constant_Numeric => C.makeFilter($loader, p, '>=', x);
    //p:the_out_param_Numeric 'is' ('smaller' | 'lower' | 'less' | 'at most' | 'not more than') x:constant_Numeric             => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Number) } 'is' ('greater than' | 'higher than' | 'larger than' | 'more than' | 'at least' | 'not less than') x:constant_Number => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Number) } 'is' ('smaller than' | 'lower than' | 'less than' | 'at most' | 'not more than') x:constant_Number  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Currency) } 'is' ('more expensive' | 'more costly' | 'more') 'than' x:constant_Currency => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Currency) } 'is' ('less expensive' | 'cheaper' | 'less') 'than' x:constant_Currency  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('ms')) } 'is' ('longer than' | 'no shorter than') x:constant_Measure_ms => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('ms')) } 'is' ('no longer than' | 'shorter than') x:constant_Measure_ms  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('byte')) } 'is' ('larger' | 'more' | 'no smaller'| 'no less') 'than' x:constant_Measure_byte => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('byte')) } 'is' ('smaller' | 'less' | 'no larger' | 'no more') 'than' x:constant_Measure_byte  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('kg')) } 'is' ('heavier' | 'larger') 'than' x:constant_Measure_kg => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('kg')) } 'is' ('lighter' | 'smaller') 'than' x:constant_Measure_kg  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('C')) } 'is' ('hotter' | 'higher') 'than' x:constant_Measure_C => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('C')) } 'is' ('cooler' | 'colder' | 'lower') 'than' x:constant_Measure_C  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m')) } 'is' ('farther' | 'more distant' | 'longer') 'than' x:constant_Measure_m => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m')) } 'is' ('nearer' | 'closer' | 'shorter' | 'no longer' | 'no farther') 'than' x:constant_Measure_m  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m2')) } 'is' ('larger' | 'bigger' | 'no smaller') 'than' x:constant_Measure_m2 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m2')) } 'is' ('smaller' | 'no larger' | 'no bigger') 'than' x:constant_Measure_m2  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m3')) } 'is' ('larger' | 'bigger' | 'no smaller') 'than' x:constant_Measure_m3 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m3')) } 'is' ('smaller' | 'no larger' | 'no bigger') 'than' x:constant_Measure_m3  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('mps')) } 'is' ('faster' | 'quicker' | 'speedier') 'than' x:constant_Measure_mps => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('mps')) } 'is' ('slower' | 'more slowly') 'than' x:constant_Measure_mps  => C.makeFilter($loader, p, '<=', x);

    !turking {
        p:out_param_Any with { type = (Type.Date) } 'is' ('after' | 'later than') x:constant_Date => C.makeFilter($loader, p, '>=', x);
        p:out_param_Any with { type = (Type.Date) } 'is' ('before' | 'earlier than' | 'sooner than') x:constant_Date => C.makeFilter($loader, p, '<=', x);
        p:out_param_Any with { type = (Type.Time) } 'is' ('after' | 'later than') x:constant_Time => C.makeFilter($loader, p, '>=', x);
        p:out_param_Any with { type = (Type.Time) } 'is' ('before' | 'earlier than' | 'sooner than') x:constant_Time => C.makeFilter($loader, p, '<=', x);
    }

    // three variants: regular containment, string containment, recurrent time spec containment
    // we cannot apply a type constraint on the regular containment because type equality would not
    // work with enums (which have incomplete type at the Ast.Value) and entities
    // makeFilter has the right logic to check types
    'the' p:out_param_Array__Any ('contain' | 'include')  x:constant_Any => C.makeFilter($loader, p, 'contains', x);
    'the' p:out_param_Array__Any 'do not' ('contain' | 'include')  x:constant_Any => C.makeFilter($loader, p, 'contains', x, true);

    'the' p:out_param_Any with { type = (Type.String) } ('contains' | 'includes') x:constant_String => C.makeFilter($loader, p, '=~', x);
    'the' p:out_param_Any with { type = (Type.String) } 'does not' ('contain' | 'include') x:constant_String => C.makeFilter($loader, p, '=~', x, true);

    'the' p:out_param_Any with { type = (Type.RecurrentTimeSpecification) } ('contains' | 'includes') x:constant_Date => C.makeFilter($loader, p, '=~', x);
    'the' p:out_param_Any with { type = (Type.RecurrentTimeSpecification) } 'does not' ('contain' | 'include') x:constant_Date => C.makeFilter($loader, p, '=~', x, true);
    'the' p:out_param_Any with { type = (Type.RecurrentTimeSpecification) } ('contains' | 'includes') x:constant_Time => C.makeFilter($loader, p, '=~', x);
    'the' p:out_param_Any with { type = (Type.RecurrentTimeSpecification) } 'does not' ('contain' | 'include') x:constant_Time => C.makeFilter($loader, p, '=~', x, true);

    x:constant_String 'is in' p:the_out_param_Any with { type = (Type.String) } => C.makeFilter($loader, p, '=~', x);

    !turking {
        ?range_filters range_filter;
    }
    //!turking f:either_filter => f;
}

edge_filter : C.FilterSlot = {
    !turking 'the' p:out_param_Any ('becomes' | 'becomes equal to') x:constant_Any => C.makeFilter($loader, p, '==', x);

    //p:the_out_param_Numeric ('is now greater than' | 'becomes greater than' | 'becomes higher than' | 'goes above' | 'increases above' | 'goes over' | 'rises above') x:constant_Numeric => C.makeFilter($loader, p, '>=', x);
    //p:the_out_param_Numeric ('is now smaller than' | 'becomes smaller than' | 'becomes lower than' | 'goes below' | 'decreases below' | 'goes under') x:constant_Numeric => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Number) } ('is now' | 'becomes' | 'goes') ('greater than' | 'higher than' | 'larger than' | 'more than' | 'at least' | 'not less than') x:constant_Number => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Number) } ('is now' | 'becomes' | 'goes') ('smaller than' | 'lower than' | 'less than' | 'at most' | 'not more than') x:constant_Number  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Currency) } ('is now' | 'becomes' | 'goes') ('more expensive' | 'more costly' | 'more') 'than' x:constant_Currency => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Currency) } ('is now' | 'becomes' | 'goes') ('less expensive' | 'cheaper' | 'less') 'than' x:constant_Currency  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('ms')) } ('is now' | 'becomes' | 'goes') 'longer than' x:constant_Measure_ms => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('ms')) } ('is now' | 'becomes' | 'goes') 'shorter than' x:constant_Measure_ms  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('byte')) } ('is now' | 'becomes' | 'goes') ('larger' | 'more') 'than' x:constant_Measure_byte => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('byte')) } ('is now' | 'becomes' | 'goes') ('smaller' | 'less') 'than' x:constant_Measure_byte  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('kg')) } ('is now' | 'becomes' | 'goes') ('heavier' | 'larger') 'than' x:constant_Measure_kg => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('kg')) } ('is now' | 'becomes' | 'goes') ('lighter' | 'smaller') 'than' x:constant_Measure_kg  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('C')) } ('is now' | 'becomes' | 'goes') ('hotter' | 'higher') 'than' x:constant_Measure_C => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('C')) } ('is now' | 'becomes' | 'goes') ('cooler' | 'colder' | 'lower') 'than' x:constant_Measure_C  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m')) } ('is now' | 'becomes' | 'goes') ('farther' | 'more distant' | 'longer') 'than' x:constant_Measure_m => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m')) } ('is now' | 'becomes' | 'goes') ('nearer' | 'closer' | 'shorter') 'than' x:constant_Measure_m  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m2')) } ('is now' | 'becomes' | 'goes') ('bigger' | 'larger') 'than' x:constant_Measure_m2 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m2')) } ('is now' | 'becomes' | 'goes') 'smaller' 'than' x:constant_Measure_m2  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m3')) } ('is now' | 'becomes' | 'goes') ('bigger' | 'larger') 'than' x:constant_Measure_m3 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m3')) } ('is now' | 'becomes' | 'goes') 'smaller' 'than' x:constant_Measure_m3  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('mps')) } ('is now' | 'becomes' | 'goes') ('faster' | 'quicker' | 'speedier') 'than' x:constant_Measure_mps => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('mps')) } ('is now' | 'becomes' | 'goes') ('slower' | 'more slowly') 'than' x:constant_Measure_mps  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Date) } ('is now' | 'becomes' | 'goes') ('after' | 'later than') x:constant_Date => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Date) } ('is now' | 'becomes' | 'goes') ('before' | 'earlier than' | 'sooner than') x:constant_Date => C.makeFilter($loader, p, '<=', x);
    p:out_param_Any with { type = (Type.Time) } ('is now' | 'becomes' | 'goes') ('after' | 'later than') x:constant_Time => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Time) } ('is now' | 'becomes' | 'goes') ('before' | 'earlier than' | 'sooner than') x:constant_Time => C.makeFilter($loader, p, '<=', x);
}

either_filter : C.FilterSlot = {
    // to account for "id in_array~ string", make two variants of this one
    ( 'the' param:out_param_Any ('is' | 'is equal to' | 'is one of' | 'is either') pair:constant_or_pairs with { type = param.type }
    | 'the' param:out_param_Any ('is' | 'is equal to' | 'is one of' | 'is either') pair:constant_or_pairs with { type = (Type.String) }
    ) => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        const [v1, v2] = pair;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is equal to true or false" does not make sense
            return null;
        return C.makeFilter($loader, param, 'in_array', new Ast.Value.Array([v1, v2]));
    };
    'the' param:out_param_Any 'is' ('not' | 'neither') pair:constant_nor_pairs with { type = param.type } => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        const [v1, v2] = pair;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is neither true nor false" does not make sense
            return null;
        return C.makeFilter($loader, param, 'in_array', new Ast.Value.Array([v1, v2]), true);
    };
}

range : [Ast.Value, Ast.Value] = {
    'between' v1:constant_Numeric 'and' v2:constant_Numeric with { type = v1.type } => {
        assert(v1.getType().equals(v2.getType()));
        if (v1.equals(v2))
            return null;
        return [v1, v2];
    };
    'in the range from' v1:constant_Numeric 'to' v2:constant_Numeric with { type = v1.type } => {
        assert(v1.getType().equals(v2.getType()));
        if (v1.equals(v2))
            return null;
        return [v1, v2];
    };
}
range_filter : C.FilterSlot = {
    'the' param:out_param_Any with { is_numeric = true } 'is' range:range with { type = param.type } => {
        const [v1, v2] = range;
        const f1 = C.makeFilter($loader, param, '>=', v1);
        const f2 = C.makeFilter($loader, param, '<=', v2);
        if (!f1 || !f2)
            return null;
        return { schema: f1.schema, ptype: f1.ptype,
            ast: new Ast.BooleanExpression.And(null, [f1.ast, f2.ast]) };
    };
}

with_filter : C.FilterSlot = {
    // note: we cannot apply a type constraint here because type equality would not
    // work with enums (which have incomplete type at the Ast.Value) and entities
    // makeFilter has the right logic to check types
    'the' p:out_param_Any 'equal to' x:constant_Any => C.makeFilter($loader, p, '==', x);
    'the' p:out_param_Any 'equal to' x:constant_Any => C.makeFilter($loader, p, '==', x);

    !turking 'the' p:out_param_Any with { type = (Type.String) } ('containing' | 'including') x:constant_String => C.makeFilter($loader, p, '=~', x);
    !turking x:constant_String ('in the' | 'in its' | 'in their') p:out_param_Any with { type = (Type.String) } => C.makeFilter($loader, p, '=~', x);
    ?schema_org 'the' p:out_param_Any with { type = (Type.String) } ('being' | 'containing' ) x:constant_String => C.makeFilter($loader, p, '=~', x);
    ?schema_org x:constant_String ('as' | 'in the' ) p:out_param_Any with { type = (Type.String) } => C.makeFilter($loader, p, '=~', x);

    // context reference filters
    'the' p:out_param_Any with { type = (Type.String) } 'equal to' x:constant_String_ContextRef => C.makeFilter($loader, p, '=~', x);
    !turking 'the' p:out_param_Any with { type = (Type.String) } ('containing' | 'including') x:constant_String_ContextRef => C.makeFilter($loader, p, '=~', x);
    !turking x:constant_String_ContextRef ('in the' | 'in its' | 'in their') p:out_param_Any with { type = (Type.String) } => C.makeFilter($loader, p, '=~', x);
    ?schema_org 'the' p:out_param_Any with { type = (Type.String) } ('being' | 'containing' ) x:constant_String_ContextRef => C.makeFilter($loader, p, '=~', x);
    ?schema_org x:constant_String_ContextRef ('as' | 'in the' ) p:out_param_Any with { type = (Type.String) } => C.makeFilter($loader, p, '=~', x);

    // substring and
    !turking 'the' p:out_param_Any with { type = (Type.String) } 'containing both' x:constant_String 'and' y:constant_String => C.makeAndFilter($loader, p, '=~', [x, y]);
    !turking 'the' p:out_param_Any with { type = (Type.String) } 'containing neither' x:constant_String 'nor' y:constant_String => C.makeAndFilter($loader, p, '=~', [x, y], true);
    !turking 'both' x:constant_String 'and' y:constant_String 'in' p:the_out_param_Any with { type = (Type.String) } => C.makeAndFilter($loader, p, '=~', [x, y]);

    // substring or
    !turking 'the' p:out_param_Any with { type = (Type.String) } 'containing either' x:constant_String 'or' y:constant_String => C.makeOrFilter($loader, p, '=~', [x, y]);
    !turking 'either' x:constant_String 'or' y:constant_String 'in' p:the_out_param_Any with { type = (Type.String) } => C.makeOrFilter($loader, p, '=~', [x, y]);

    // substring but
    !turking 'the' p:out_param_Any with { type = (Type.String) } ('containing' | 'including') x:constant_String ('but not'| 'without' | 'but no') y:constant_String => C.makeButFilter($loader, p, '=~', [x, y]);

    //p:out_param_Numeric ('higher' | 'larger' | 'bigger') 'than' x:constant_Numeric => C.makeFilter($loader, p, '>=', x);
    //p:out_param_Numeric ('smaller' | 'lower') 'than' x:constant_Numeric => C.makeFilter($loader, p, '<=', x);
    p:out_param_Any with { type = (Type.Number) } ('greater than' | 'higher than' | 'larger than' | 'more than' | 'at least' | 'not less than') x:constant_Number => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Number) } ('smaller than' | 'lower than' | 'less than' | 'at most' | 'not more than') x:constant_Number  => C.makeFilter($loader, p, '<=', x);
    x:constant_Number ('or more' | 'or higher' | 'or greater' | 'or above') 'the' p:out_param_Any with { type = (Type.Number) } => C.makeFilter($loader, p, '>=', x);
    x:constant_Number ('or less' | 'or lower' | 'or below') 'the' p:out_param_Any with { type = (Type.Number) } => C.makeFilter($loader, p, '<=', x);
    !turking 'over' x:constant_Number p:out_param_Any with { type = (Type.Number) } => C.makeFilter($loader, p, '>=', x);

    p:out_param_Any with { type = (Type.Currency) } ('more expensive' | 'more costly' | 'more') 'than' x:constant_Currency => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Currency) } ('less expensive' | 'cheaper' | 'less') 'than' x:constant_Currency  => C.makeFilter($loader, p, '<=', x);
    x:constant_Currency ('or more' | 'or above') 'the' p:out_param_Any with { type = (Type.Currency) } => C.makeFilter($loader, p, '>=', x);
    x:constant_Currency ('or less' | 'or cheaper' | 'or below') 'the' p:out_param_Any with { type = (Type.Currency) } => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('ms')) } 'longer than' x:constant_Measure_ms => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('ms')) } 'shorter than' x:constant_Measure_ms  => C.makeFilter($loader, p, '<=', x);
    x:constant_Measure_ms ('or longer' | 'or more' ) 'the' p:out_param_Any with { type = (new Type.Measure('ms')) } => C.makeFilter($loader, p, '>=', x);
    x:constant_Measure_ms ('or shorter' | 'or less' ) 'the' p:out_param_Any with { type = (new Type.Measure('ms')) } => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('byte')) } ('larger' | 'more') 'than' x:constant_Measure_byte => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('byte')) } ('smaller' | 'less') 'than' x:constant_Measure_byte  => C.makeFilter($loader, p, '<=', x);
    x:constant_Measure_byte ('or larger' | 'or more' ) 'the' p:out_param_Any with { type = (new Type.Measure('byte')) } => C.makeFilter($loader, p, '>=', x);
    x:constant_Measure_byte ('or smaller' | 'or less' ) 'the' p:out_param_Any with { type = (new Type.Measure('byte')) } => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('kg')) } ('heavier' | 'larger') 'than' x:constant_Measure_kg => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('kg')) } ('lighter' | 'smaller') 'than' x:constant_Measure_kg  => C.makeFilter($loader, p, '<=', x);
    x:constant_Measure_kg 'or more' 'the' p:out_param_Any with { type = (new Type.Measure('kg')) } => C.makeFilter($loader, p, '>=', x);
    x:constant_Measure_kg 'or less' 'the' p:out_param_Any with { type = (new Type.Measure('kg')) } => C.makeFilter($loader, p, '<=', x);
    !turking 'over' x:constant_Measure_kg p:out_param_Any with { type = (new Type.Measure('kg')) } => C.makeFilter($loader, p, '>=', x);

    p:out_param_Any with { type = (new Type.Measure('C')) } ('hotter' | 'higher') 'than' x:constant_Measure_C => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('C')) } ('cooler' | 'colder' | 'lower') 'than' x:constant_Measure_C  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m')) } ('farther' | 'more distant' | 'longer') 'than' x:constant_Measure_m => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m')) } ('nearer' | 'closer' | 'shorter') 'than' x:constant_Measure_m  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m2')) } ('larger' | 'bigger') 'than' x:constant_Measure_m2 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m2')) } 'smaller' 'than' x:constant_Measure_m2  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('m3')) } ('larger' | 'bigger') 'than' x:constant_Measure_m3 => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('m3')) } 'smaller' 'than' x:constant_Measure_m3  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (new Type.Measure('mps')) } ('faster' | 'quicker' | 'speedier') 'than' x:constant_Measure_mps => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (new Type.Measure('mps')) } ('slower' | 'more slowly') 'than' x:constant_Measure_mps  => C.makeFilter($loader, p, '<=', x);

    p:out_param_Any with { type = (Type.Date) } ('after' | 'later than') x:constant_Date => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Date) } ('before' | 'earlier than' | 'sooner than') x:constant_Date => C.makeFilter($loader, p, '<=', x);
    p:out_param_Any with { type = (Type.Time) } ('after' | 'later than') x:constant_Time => C.makeFilter($loader, p, '>=', x);
    p:out_param_Any with { type = (Type.Time) } ('before' | 'earlier than' | 'sooner than') x:constant_Time => C.makeFilter($loader, p, '<=', x);

    //('higher' | 'larger' | 'bigger') p:out_param_Numeric 'than' x:constant_Numeric => C.makeFilter($loader, p, '>=', x);
    //('smaller' | 'lower') p:out_param_Numeric 'than' x:constant_Numeric => C.makeFilter($loader, p, '<=', x);
    ('greater' | 'higher' | 'larger' | 'more' ) p:out_param_Any with { type = (Type.Number) } 'than' x:constant_Number => C.makeFilter($loader, p, '>=', x);
    ('smaller' | 'lower' | 'less') p:out_param_Any with { type = (Type.Number) } 'than' x:constant_Number  => C.makeFilter($loader, p, '<=', x);

    ('more expensive' | 'more costly' | 'more') p:out_param_Any with { type = (Type.Currency) } 'than' x:constant_Currency => C.makeFilter($loader, p, '>=', x);
    ('less expensive' | 'cheaper' | 'less') p:out_param_Any with { type = (Type.Currency) } 'than' x:constant_Currency  => C.makeFilter($loader, p, '<=', x);

    'longer' p:out_param_Any with { type = (new Type.Measure('ms')) } 'than' x:constant_Measure_ms => C.makeFilter($loader, p, '>=', x);
    'shorter' p:out_param_Any with { type = (new Type.Measure('ms')) } 'than' x:constant_Measure_ms  => C.makeFilter($loader, p, '<=', x);

    ('larger' | 'more') p:out_param_Any with { type = (new Type.Measure('byte')) } 'than' x:constant_Measure_byte => C.makeFilter($loader, p, '>=', x);
    ('smaller' | 'less') p:out_param_Any with { type = (new Type.Measure('byte')) } 'than' x:constant_Measure_byte  => C.makeFilter($loader, p, '<=', x);

    ('heavier' | 'larger') p:out_param_Any with { type = (new Type.Measure('kg')) } 'than' x:constant_Measure_kg => C.makeFilter($loader, p, '>=', x);
    ('lighter' | 'smaller') p:out_param_Any with { type = (new Type.Measure('kg')) } 'than' x:constant_Measure_kg  => C.makeFilter($loader, p, '<=', x);

    ('hotter' | 'higher') p:out_param_Any with { type = (new Type.Measure('C')) } 'than' x:constant_Measure_C => C.makeFilter($loader, p, '>=', x);
    ('cooler' | 'colder' | 'lower') p:out_param_Any with { type = (new Type.Measure('C')) } 'than' x:constant_Measure_C  => C.makeFilter($loader, p, '<=', x);

    ('farther' | 'more distant' | 'longer') p:out_param_Any with { type = (new Type.Measure('m')) } 'than' x:constant_Measure_m => C.makeFilter($loader, p, '>=', x);
    ('nearer' | 'closer' | 'shorter') p:out_param_Any with { type = (new Type.Measure('m')) } 'than' x:constant_Measure_m  => C.makeFilter($loader, p, '<=', x);

    ('bigger' | 'larger' ) p:out_param_Any with { type = (new Type.Measure('m2')) } 'than' x:constant_Measure_m2 => C.makeFilter($loader, p, '>=', x);
    'smaller' p:out_param_Any with { type = (new Type.Measure('m2')) } 'than' x:constant_Measure_m2  => C.makeFilter($loader, p, '<=', x);

    ('bigger' | 'larger' ) p:out_param_Any with { type = (new Type.Measure('m3')) } 'than' x:constant_Measure_m3 => C.makeFilter($loader, p, '>=', x);
    'smaller' p:out_param_Any with { type = (new Type.Measure('m3')) } 'than' x:constant_Measure_m3  => C.makeFilter($loader, p, '<=', x);

    ('faster' | 'quicker' | 'speedier') p:out_param_Any with { type = (new Type.Measure('mps')) } 'than' x:constant_Measure_mps => C.makeFilter($loader, p, '>=', x);
    ('slower' | 'more slowly') p:out_param_Any with { type = (new Type.Measure('mps')) } 'than' x:constant_Measure_mps  => C.makeFilter($loader, p, '<=', x);

    'later' p:out_param_Any with { type = (Type.Date) } 'than' x:constant_Date => C.makeFilter($loader, p, '>=', x);
    ('earlier' | 'sooner') p:out_param_Any with { type = (Type.Date) } 'than' x:constant_Date => C.makeFilter($loader, p, '<=', x);
    'later' p:out_param_Any with { type = (Type.Time) } 'than' x:constant_Time => C.makeFilter($loader, p, '>=', x);
    ('earlier' | 'sooner') p:out_param_Any with { type = (Type.Time) } 'than' x:constant_Time => C.makeFilter($loader, p, '<=', x);

    !turking {
        ?range_filters f:range_with_filter => f;
        'no' param:out_param_Any with { type = (Type.Number) } => C.makeFilter($loader, param, '==', new Ast.Value.Number(0));
        'zero' param:out_param_Any with { type = (Type.Number) } => C.makeFilter($loader, param, '==', new Ast.Value.Number(0));
    }

    // array
    p:out_param_Array__Any 'containing' x:constant_Any => C.makeFilter($loader, p, 'contains', x);
    p:out_param_Array__Any 'containing no' x:constant_Any => C.makeFilter($loader, p, 'contains', x, true);
    x:constant_Any 'in' 'the' p:out_param_Array__Any => C.makeFilter($loader, p, 'contains', x);

    // array contain and
    !turking p:out_param_Array__Any 'containing' both_prefix pair:constant_pairs with { type = p.elem } => C.makeAndFilter($loader, p, 'contains', pair);
    !turking both_prefix pair:constant_pairs 'in' 'the' p:out_param_Array__Any with { elem = pair.type } => C.makeAndFilter($loader, p, 'contains', pair);

    // array contain or
    p:out_param_Array__Any 'containing either' pair:constant_or_pairs with { type = p.elem } => C.makeOrFilter($loader, p, 'contains', pair);
    'either' pair:constant_or_pairs 'in' 'the' p:out_param_Array__Any with { elem = pair.type } => C.makeOrFilter($loader, p, 'contains', pair);

    // array but
    !turking p:out_param_Any with { type = (Type.Any) } ('containing' | 'including') x:constant_String ('but not'| 'without' | 'but no') y:constant_String => C.makeButFilter($loader, p, 'contains', [x, y]);

    // aggregate filters - count
    !turking ('no' | 'zero') p:out_param_Array__Any => C.makeAggregateFilter(p, 'count', '*', '==', new Ast.Value.Number(0));
    x:constant_Number p:out_param_Array__Any => C.makeAggregateFilter(p, 'count', '*', '==', x);

    !turking ('no' | 'zero') p:out_param_ArrayCount => C.makeFilter($loader, p, '==', new Ast.Value.Number(0));
    x:constant_Number p:out_param_ArrayCount => C.makeFilter($loader, p, '==', x);

    !turking ('no' | 'zero') p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('lower than' | 'below') x:constant_Numeric with { type = f.type } => {
        const filter =  C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', new Ast.Value.Number(0));
    };
    !turking ('no' | 'zero') p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('greater than' | 'above') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', new Ast.Value.Number(0));
    };

    p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('greater than' | 'above') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', new Ast.Value.Number(1));

    };

    p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('lower than' | 'below') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', new Ast.Value.Number(1));
    };

    p:out_param_Array__Compound ('with' | 'having') f:with_filter => {
        return C.makeAggregateFilterWithFilter(p, f, 'count', '*', '>=', new Ast.Value.Number(1));
    };

    v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('greater than' | 'above') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', v);
    };

    ('more than' | 'at least' | 'no fewer than') x:constant_Number p:out_param_Array__Any => C.makeAggregateFilter(p, 'count', '*', '>=', x);
    ('fewer than' | 'at most' | 'no more than') x:constant_Number p:out_param_Array__Any => C.makeAggregateFilter(p, 'count', '*', '<=', x);
    ('more than' | 'at least' | 'no fewer than') x:constant_Number p:out_param_ArrayCount => C.makeFilter($loader, p, '>=', x);
    ('fewer than' | 'at most' | 'no more than') x:constant_Number p:out_param_ArrayCount => C.makeFilter($loader, p, '<=', x);

    // do not merge
    'no more than' v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('lower than' | 'below') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    };
    'at most' v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('lower than' | 'below') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    };
    'fewer than' v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('lower than' | 'below') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    };

    // do not merge
    'more than' v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('greater than' | 'above') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', v);
    };
    'at least' v:constant_Number p:out_param_Array__Compound ('with' | 'having') f:out_param_Any with { is_numeric = true } ('greater than' | 'above') x:constant_Numeric with { type = f.type } => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', v);
    };

    // aggregate filters - sum
    ('total' | 'sum') p:out_param_Array__Any with { is_numeric_elem = true } ('of' | 'being' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'sum', null, '==', x);
    ('total' | 'sum') p:out_param_Array__Any with { is_numeric_elem = true } ('greater than' | 'more than' | 'above' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'sum', null, '>=', x);
    ('total' | 'sum') p:out_param_Array__Any with { is_numeric_elem = true } ('lower than' | 'less than' | 'below' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'sum', null, '<=', x);

    !turking ('total' | 'sum') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('of' | 'being') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'sum', f, '==', x);
    !turking ('total' | 'sum') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('greater than' | 'more than' | 'higher than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'sum', f, '>=', x);
    !turking ('total' | 'sum') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('smaller than' | 'less than' | 'lower than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'sum', f, '>=', x);

    // aggregate filters - avg
    'average' p:out_param_Array__Any with { is_numeric_elem = true } ('of' | 'being' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'avg', null, '==', x);
    'average' p:out_param_Array__Any with { is_numeric_elem = true } ('greater than' | 'more than' | 'above') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'avg', null, '>=', x);
    'average' p:out_param_Array__Any with { is_numeric_elem = true } ('lower than' | 'less than' | 'below') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'avg', null, '<=', x);

    !turking 'average' f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('of' | 'being') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'avg', f, '==', x);
    !turking 'average' f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('greater than' | 'more than' | 'higher than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'avg', f, '>=', x);
    !turking 'average' f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('smaller than' | 'less than' | 'lower than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'avg', f, '>=', x);

    // aggregate filters - max
    ('maximum' | 'highest') p:out_param_Array__Any with { is_numeric_elem = true } ('of' | 'being' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'max', null, '==', x);
    ('maximum' | 'highest') p:out_param_Array__Any with { is_numeric_elem = true } ('greater than' | 'more than' | 'above') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'max', null, '>=', x);
    ('maximum' | 'highest') p:out_param_Array__Any with { is_numeric_elem = true } ('lower than' | 'less than' | 'below') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'max', null, '<=', x);

    !turking ('maximum' | 'highest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('of' | 'being') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'max', f, '==', x);
    !turking ('maximum' | 'highest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('greater than' | 'more than' | 'higher than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'max', f, '>=', x);
    !turking ('maximum' | 'highest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('smaller than' | 'less than' | 'lower than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'max', f, '>=', x);

    // aggregate filters - min
    ('minimum' | 'lowest') p:out_param_Array__Any with { is_numeric_elem = true } ('of' | 'being' ) x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'min', null, '==', x);
    ('minimum' | 'lowest') p:out_param_Array__Any with { is_numeric_elem = true } ('greater than' | 'more than' | 'above') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'min', null, '>=', x);
    ('minimum' | 'lowest') p:out_param_Array__Any with { is_numeric_elem = true } ('lower than' | 'less than' | 'below') x:constant_Numeric with { type = p.elem } => C.makeAggregateFilter(p, 'min', null, '<=', x);

    !turking ('minimum' | 'lowest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('of' | 'being') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'min', f, '==', x);
    !turking ('minimum' | 'lowest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('greater than' | 'more than' | 'higher than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'min', f, '>=', x);
    !turking ('minimum' | 'lowest') f:out_param_Any with { is_numeric = true } 'of' p:out_param_Array__Compound ('smaller than' | 'less than' | 'lower than') x:constant_Numeric with { type = f.type } => C.makeAggregateFilter(p, 'min', f, '>=', x);
}

// XXX ? what's going on here? fname is entirely unused?
/*
for (let pname in _tpLoader.compoundArrays) {
    for (let fname in _tpLoader.compoundArrays[pname].fields) {
        if (_tpLoader.compoundArrays[pname].fields[fname].type.isNumeric()) {
            with_filter : C.FilterSlot = {
                ('total' | 'sum') f:out_param_Numeric ('of' | 'being') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'sum', f.name, '==', x);
                ('total' | 'sum') f:out_param_Numeric ('greater than' | 'more than' | 'higher than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'sum', f.name, '>=', x);
                ('total' | 'sum') f:out_param_Numeric ('smaller than' | 'less than' | 'lower than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'sum', f.name, '>=', x);

                'average' f:out_param_Numeric ('of' | 'being') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'avg', f.name, '==', x);
                'average' f:out_param_Numeric ('greater than' | 'more than' | 'higher than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'avg', f.name, '>=', x);
                'average' f:out_param_Numeric ('smaller than' | 'less than' | 'lower than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'avg', f.name, '>=', x);

                ('maximum' | 'highest') f:out_param_Numeric ('of' | 'being') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'max', f.name, '==', x);
                ('maximum' | 'highest') f:out_param_Numeric ('greater than' | 'more than' | 'higher than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'max', f.name, '>=', x);
                ('maximum' | 'highest') f:out_param_Numeric ('smaller than' | 'less than' | 'lower than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'max', f.name, '>=', x);

                ('minimum' | 'lowest') f:out_param_Numeric ('of' | 'being') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'min', f.name, '==', x);
                ('minimum' | 'lowest') f:out_param_Numeric ('greater than' | 'more than' | 'higher than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'min', f.name, '>=', x);
                ('minimum' | 'lowest') f:out_param_Numeric ('smaller than' | 'less than' | 'lower than') x:constant_Numeric => C.makeAggregateFilter(new Ast.Value.VarRef(pname), 'min', f.name, '>=', x);
            }
        }
    }
}
*/


range_with_filter : C.FilterSlot = {
    param:out_param_Any with { is_numeric = true } range:range => {
        const [v1, v2] = range;
        const f1 = C.makeFilter($loader, param, '>=', v1);
        const f2 = C.makeFilter($loader, param, '<=', v2);
        if (!f1 || !f2)
            return null;
        return { schema: f1.schema, ptype: f1.ptype,
            ast: new Ast.BooleanExpression.And(null, [f1.ast, f2.ast]) };
    };
}

// add the "both" prefix that is used by auto-generated *_filters
both_prefix : string = {
    'both';
}

nearby_filter : C.DomainIndependentFilterSlot = {
    ('here' | 'around here' | 'near here') => C.makeDomainIndependentFilter('geo', '==', HERE);
    ('nearby' | 'around me' | 'in this area') => C.makeDomainIndependentFilter('geo', '==', HERE);
    ('in' | 'around' | 'near') x:constant_Location => C.makeDomainIndependentFilter('geo', '==', x);
}

// filters on npp parameter for "whose" question
// e.g.: whose nickname is boogie?
whose_npp_filter : C.FilterSlot = {
    p:out_param_Any 'is' x:constant_Any => C.makeFilter($loader, p, '==', x);
    p:out_param_Any 'is' x:constant_Any => C.makeFilter($loader, p, 'contains', x);
}


//FIXME: calculate threshold using max rating instead of a fixed number
quality_filter : C.DomainIndependentFilterSlot = {
    ('good' | 'great' | 'nice' | 'decent') => C.makeDomainIndependentFilter('aggregateRating.ratingValue', '>=', new Ast.Value.Number(4));
}

within_filter : ({ distance : Ast.Value, place : Ast.Value }) = {
    'within' distance:constant_Measure_m ('' | 'radius' | 'of here' | 'from here' | 'from me' | 'of me' | 'of this area' | 'of my location' | 'from current location') => ({ distance, place: HERE });

    'within' distance:constant_Measure_m ('' | 'radius') ('of' | 'from') place:constant_Location
        => ({ distance, place });
}
