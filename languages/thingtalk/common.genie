// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

{
// import the combinator library
const C = require('./ast_manip');
}

import './common-constants';

// Thingpedia Grammar Rules

// the following are a all autogenerated by load-thingpedia.js

thingpedia_query = {}
thingpedia_get_command = {}
thingpedia_stream = {}
thingpedia_action = {}
thingpedia_program = {}
thingpedia_who_question = {}

thingpedia_search_question = {}
thingpedia_slot_fill_question = {}
thingpedia_user_question = {}

thingpedia_result = {}
thingpedia_action_past = {}
thingpedia_error_message = {}

coref_constant = {}

out_param_Numeric = {
    out_param_Number;
    out_param_Currency;
    out_param_Measure_ms;
    out_param_Measure_byte;
    out_param_Measure_kg;
    out_param_Measure_C;
    out_param_Measure_m;
    out_param_Measure_mps;
}

out_param_Any = {}
out_param_Array__Any = {}
out_param_ArrayCount = {}
out_param_npp = {}
out_param_npi = {}
out_param_avp = {}
out_param_pvp = {}
out_param_npv = {}
out_param_apv = {}
out_param_String   = {}
out_param_Number   = {}
out_param_Currency = {}
out_param_Time     = {}
out_param_Date     = {}
out_param_Location = {}
out_param_Measure_ms   = {}
out_param_Measure_byte = {}
out_param_Measure_kg   = {}
out_param_Measure_C    = {}
out_param_Measure_m    = {}
out_param_Measure_mps  = {}

out_param_Array__Numeric = {
    out_param_Array__Number;
    out_param_Array__Currency;
    out_param_Array__Measure_ms;
    out_param_Array__Measure_byte;
    out_param_Array__Measure_kg;
    out_param_Array__Measure_C;
    out_param_Array__Measure_m;
    out_param_Array__Measure_mps;
}

out_param_Array__String   = {}
out_param_Array__Number   = {}
out_param_Array__Currency = {}
out_param_Array__Time     = {}
out_param_Array__Date     = {}
out_param_Array__Location = {}
out_param_Array__Measure_ms   = {}
out_param_Array__Measure_byte = {}
out_param_Array__Measure_kg   = {}
out_param_Array__Measure_C    = {}
out_param_Array__Measure_m    = {}
out_param_Array__Measure_mps  = {}
out_param_Array__Compound = {}  // used for aggregate filter only

input_param = {}

// helper prefix for "and" filters
// English overrides this to add "both" as well
both_prefix = {
    '';
}

// filters & input parameters on npp parameters
// nnp: Noun-Phrase parameter for Property of the subject
// e.g.: "name", "date of birth"

npp_filter = {}
npp_input_param = {}
coref_npp_filter = {}
coref_npp_input_param = {}

// filters & input parameters on npi parameters
// npi: Noun-phrase parameter for Identity of the subejct
// e.g.: "owner of <company>", "student in <university>"
npi_filter = {}
npi_input_param = {}
coref_npi_filter = {}
coref_npi_input_param = {}

// filters & input parameters on pvp parameters
// pvp: Passive-Verb Phrase parameter
// e.g.: "called <nickname>", "born on <date>"
pvp_filter = {}
pvp_input_param = {}
coref_pvp_filter = {}
coref_pvp_input_param = {}

// filters & input parameters on prep parameters
// prep: preposition parameter
// e.g.: "at <time>", "in <area>"
preposition_filter = {}
preposition_input_param = {}
coref_preposition_filter = {}
coref_preposition_input_param = {}

// filters & input parameters on avp parameters
// avp: Active-Verb Phrase parameter
// e.g.: "owns <company>", "studied in <university>"
avp_filter = {}
avp_input_param = {}
coref_avp_filter = {}
coref_avp_input_param = {}

// filters & input parameters on npv parameters
// npv: implicit parameter with Noun-Phrase Value, i.e., the parameter itself will not appear in the sentence
// e.g.: "Bob is a PhD", the parameter `academic_degree` is implicit, and should be inferred by the value "PhD"
npv_filter = {}
npv_input_param = {}
coref_npv_filter = {}
coref_npv_input_param = {}

// filters & input parameters on apv parameter
// apv: implicit parameter with Adjective-Phrase Value (similar to npv, but in adjective form)
// e.g.: "Bob is left-handed"
apv_filter = {}
apv_input_param = {}
coref_apv_filter = {}
coref_apv_input_param = {}

// projection in reversed verb form
// e.g., "who [wrote] book X", "which [album includes] song Y"
reverse_verb_projection = {}
who_reverse_verb_projection = {}

constant_name = {}

base_table = {}
base_noun_phrase = {}
generic_anything_noun_phrase = {}
generic_base_noun_phrase = {}

{
const _tpLoader = require('./load-thingpedia');
await _tpLoader.init($runtime, $grammar, $locale, $options);
}

// empty defaults for certain parameter types in case we don't have devices with
// those parameters
projection_Entity__tt__username = {}
projection_Entity__tt__email_address = {}

for (let [pname, [typestr,]] of _tpLoader.params.in.values()) {
    thingpedia_stream = {
        s:thingpedia_stream v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(s, pname, v);
    }

    thingpedia_query = {
        q:thingpedia_query v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(q, pname, v);
    }

    thingpedia_get_command = {
        q:thingpedia_get_command v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(q, pname, v);
    }

    thingpedia_action = {
        a:thingpedia_action v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(a, pname, v);
    }

    thingpedia_action_past = {
        a:thingpedia_action v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(a, pname, v);
    }

    thingpedia_error_message = {
        msg:thingpedia_error_message v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replaceErrorMessagePlaceholder(msg, pname, v);
    }

    if (typestr.startsWith('Entity')) {
        thingpedia_action_past = {
            a:thingpedia_action v:constant_name [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(a, pname, v);
        }

        thingpedia_error_message = {
            msg:thingpedia_error_message v:constant_name [-> pname { isConstant: true }] => C.replaceErrorMessagePlaceholder(msg, pname, v);
        }
    }

    thingpedia_program = {
        p:thingpedia_program v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(p, pname, v);
    }

    // don't parameter pass booleans or enums, as that rarely makes sense
    if (typestr !== 'Boolean' && !typestr.startsWith('Enum__')) {
        if (pname !== 'count' && pname !== 'p_count') {
            if ($options.flags.undefined_filter) {
                // replace $-placeholders with "some X" where X is based on parameter type
                thingpedia_query = q:thingpedia_query $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pname, typestr);

                thingpedia_get_command = q:thingpedia_get_command $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pname, typestr);

                thingpedia_stream = s:thingpedia_stream $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(s, pname, typestr);

                thingpedia_action = a:thingpedia_action $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(a, pname, typestr);

                thingpedia_program = p:thingpedia_program $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(p, pname, typestr);
            }
        }
    }
}

for (let [pname, typestr] of _tpLoader.params.out.values()) {
    if (typestr !== null) {
        thingpedia_result = {
            bag:thingpedia_result v:$('constant_name') [-> pname { isConstant: true }] => C.replaceSlotBagPlaceholder(bag, pname, v);
            bag:thingpedia_result v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replaceSlotBagPlaceholder(bag, pname, v);
        }
    }
}
