class @com.facebook
#_[name="Facebook"]
#_[canonical="facebook"] {
  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.oauth2();

  action post(in req status: String
              #_[prompt="what do you want to post"]
              #_[canonical={
                 base=["status", "text", "content"],
                 preposition=["saying #"]
              }]
              #[string_values="tt:long_free_text"])
  #_[canonical=["post on facebook", "make a post on facebook", "update your facebook status"]]
  #_[confirmation="post $status on Facebook"]
  #[confirm=true];

  action post_picture(in req picture_url: Entity(tt:picture)
                      #_[prompt="upload the picture now"]
                      #_[canonical={
                         base=["picture", "image", "photo"],
                      }],
                      in req caption: String
                      #_[prompt="what should be the caption of the picture"]
                      #_[canonical={
                         base=["caption", "message", "description"],
                         preposition=["saying #"]
                      }]
                      #[string_values="com.instagram:caption"])
  #_[canonical=["post a picture on facebook", "upload a picture to facebook"]]
  #_[confirmation="upload a picture on Facebook with caption $caption"]
  #[confirm=true];
}
class @org.thingpedia.builtin.thingengine.builtin
#_[name="Miscellaneous Interfaces"]
#_[description="Commands that are always available and don't belong to any specific device or account. Mostly related to time and randomness, because the universe is chaos and those always there. Also debugging."]
#_[canonical="miscellaneous interfaces"]
{
  import loader from @org.thingpedia.builtin();
  import config from @org.thingpedia.config.builtin();

  monitorable query get_gps(out location: Location
                            #_[canonical={
                              default="preposition",
                              base=["coordinates"],
                              preposition=["in #", "at #", "around #"]
                            }],
                            out altitude: Measure(m)
                            #_[canonical={
                              default="base",
                              base=["altitude"],
                              preposition=["at # above sea level"]
                            }]
                            #[min_number=0m]
                            #[max_number=15000m], // not approved for use in the ISS
                            out bearing: Number
                            #_[canonical={
                              base=["bearing"],
                              passive_verb=["facing #"] // FIXME we want to say "facing 30 degrees north" but we can't quite do that...
                            }],
                            out speed: Measure(mps)
                            #_[canonical={
                              base=["speed"],
                              passive_verb=["going at #", "moving at #"],
                              preposition=["at #"]
                            }]
                            )
  #_[canonical=["my current location", "my current position", "my current geocoordinates"]]
  #_[confirmation="your location"]
  #_[formatted=[{type="text",text="Current Location: ${location}"}]]
  #[poll_interval=0ms]
  #[doc="get last known GPS location"]
  #[confirm=false];

  query get_time(out time: Time
                 #_[canonical=["time"]]
                 #[filterable=false])
  #[result=["it 's ${time}", "the current time is ${time}", "now it 's ${time}"]]
  #_[canonical=["time", "current time", "time of day"]]
  #_[confirmation="the current time"]
  #_[formatted=[{type="text",text="Current time is ${time:time}."}]]
  #[doc="get the current time"]
  #[confirm=false];

  query get_date(out date: Date
                 #_[canonical=["date"]]
                 #[filterable=false])
  #_[canonical=["date", "current date", "today 's date"]]
  #_[confirmation="today's date"]
  #_[formatted=[{type="text",text="Today is ${date:date}."}]]
  #[doc="get the current date"]
  #[confirm=false];

  query get_random_between(in opt low: Number
                           #_[canonical={
                             base=["lower bound", "minimum number"],
                             passive_verb=["higher than #", "more than #"] // the sentence is "give me a random number higher than X", so "higher than X" is pvp not apv
                           }],
                           in opt high: Number
                           #_[canonical={
                             base=["upper bound", "maximum number"],
                             passive_verb=["higher than #", "more than #"] // the sentence is "give me a random number higher than X", so "higher than X" is pvp not apv
                           }],
                           out random: Number
                           #_[canonical={
                             base=["number", "result"],
                           }]
                           #[filterable=false])
  #_[canonical=["random number", "random integer"]]
  #_[result=["${random}", "your number is ${random} .", "i chose ${random} ."]]
  #_[confirmation="a random integer between $low and $high"]
  #_[formatted=[{type="text",text="${random}"}]]
  #[doc="get a uniform random integer between `low` and `high`"]
  #[confirm=false];

  /*list query device(out id : Entity(tt:device)
                    #_[canonical={
                       base=["name"],
                       passive_verb=["named #", "called #"],
                    }],
                    out description : String
                    #_[canonical={
                       base=["description"]
                    }]
                    #[string_values="tt:short_free_text"],
                    out category : Enum(service, media, social_network, communication, home, health, data_management)
                    #_[canonical={
                       base=["category"],
                       adjective=["#"],
                       preposition=["in the # category"]
                    }],
                    out website : Entity(tt:url)
                    #_[canonical={
                       base=["website", "link", "url"]
                    }]
                    )
  #_[canonical=["device", "skill", "thingpedia device", "supported skill"]]
  #_[confirmation="Thingpedia devices"]
  #_[formatted=[{type="text",text="${random}"}]]
  #[doc="list supported Thingpedia devices"]
  #[confirm=false];

  list query commands(out id : Entity(tt:command_id),
                      out device: Entity(tt:device)
                      #_[canonical={
                        base=["device", "account", "skill"],
                        adjective=["# 's"],
                        preposition=["of #", "in #"]
                      }]
                      #_[prompt=["what device do you want help for", "for what device"]],
                      out program: Entity(tt:program)
                      #[filterable=false])
  #_[canonical="supported command"]
  #_[confirmation="the list of commands of $device"]
  #_[formatted=[{type="text",text="${program}"}]]
  #[doc="retrieve the list of supported commands for the given device"]
  #[confirm=false];
  */

  action open_url(in req url: Entity(tt:url)
                  #_[prompt=["what url do you want to open", "what do you want to open"]]
                  #_[canonical={
                    base=["url", "link", "page"],
                    preposition=["to #"]
                  }])
  #_[canonical=["open a url", "open a link"]]
  #_[confirmation="open $url"]
  #[doc="open a file/link"]
  #[confirm=false];

  action say(in req message: String
             #_[prompt="what do you want me to say"]
             #[string_values="tt:long_free_text"],
             out message_output: String
             #_[canonical="message"])
  #_[result="${message_output}"]
  #_[canonical="say"]
  #_[confirmation="send me a message $message"]
  #[doc="makes Almond say something"]
  #[confirm=false];

  action debug_log(in req message: String
                   #_[prompt=["what should I write in the logs", "what do you want me to write"]]
                   #[string_values="tt:long_free_text"])
  #_[canonical=["log a message", "record a message", "write a message in the logs"]]
  #_[confirmation="write $message in the developer logs"]
  #[doc="log a message in the developer logs"]
  #[confirm=false];

  action faq_reply(in req question: Enum(about_almond_identity,about_almond_location,general_help)
                   #_[prompt="what do you would like to know"]
                   #_[canonical="message"],
                   out reply: String
                   #_[canonical=["reply", "answer"]])
  #_[result="${reply}"]
  #_[canonical="ask question about almond"]
  #_[confirmation="reply to $question"]
  #[doc="asks a question about Almond"]
  #[confirm=false];

/*
  action configure(in req device: Entity(tt:device) #_[prompt="What device do you want to configure?"])
  #_[canonical="configure"]
  #_[confirmation="configure a new $device"]
  #_[confirmation_remote="configure a new $device on $__person's Almond"]
  #[doc="configure a specific device by type"]
  #[confirm=false];

  action discover()
  #_[canonical="discover"]
  #_[confirmation="search for new devices"]
  #_[confirmation_remote="search for new devices on $__person's Almond"]
  #[doc="start interactive discovery for new devices"]
  #[confirm=false];
*/
}
class @com.twitter
#_[name="Twitter"]
#_[description="Connect your Mario with Twitter"]
#_[canonical="twitter"]
{
  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.oauth2();

  entity tweet #_[description="Twitter Tweet ID"] #[has_ner=false];

  monitorable list query tweet(out id : Entity(com.twitter:tweet)
                               #[unique=true]
                               #_[canonical={
                                  base=["id", "tweet id"],
                               }],

                               out text: String
                               #_[canonical={
                                  base=["text", "content"],
                                  verb=["contain #", "say #", "talk about #"],
                                  passive_verb=["matching #", "containing #", "saying #"],
                                  preposition=["about #"]
                               }]
                               #[string_values="tt:long_free_text"],

                               out hashtags: Array(Entity(tt:hashtag))
                               #_[canonical={
                                 base=["hashtags"],
                                 property=["hashtag #", "# hashtag"],
                               }]
                               #[string_values="com.twitter:hashtag"],

                               out urls: Array(Entity(tt:url))
                               #_[canonical="urls"],

                               out author: Entity(tt:username)
                               #_[prompt="from which user do you want tweets"]
                               #_[canonical={
                                  base=["author", "user"],
                                  passive_verb=["authored by #", "written by #"],
                                  preposition=["from #", "by #"]
                               }]
                               #[string_values="com.twitter:username"],

                               out from_self : Boolean
                               #_[canonical={ preposition_true=["from me"], adjective_true=["my"] }],

                               out in_reply_to: Entity(tt:username)
                               #_[prompt="in reply to which user do you want tweets?"]
                               #_[canonical={
                                  base=["mentioned user", "mention"],
                                  passive_verb=["replying to #"],
                                  verb=["reply to #"],
                                  preposition=["in reply to #"]
                               }]
                               #[string_values="com.twitter:username"]
                               )
  #_[canonical=["tweet", "recent tweet"]]
  #_[result=["${author} tweeted : ${text}"]]
  #_[formatted=[{type="text",text="@${author} tweeted: ${text}"}]]
  #_[confirmation_remote="recent tweets"]
  #[related=["com.twitter:home_timeline"]]
  #[poll_interval=600000ms]
  #[doc="search recent tweets; default is 5"];

  monitorable list query home_timeline(out id: Entity(com.twitter:tweet)
                                       #[unique=true]
                                       #_[canonical={
                                          base=["id", "tweet id"],
                                       }],

                                       out text: String
                                       #_[canonical={
                                          base=["text", "content"],
                                          verb=["contain #", "say #", "talk about #"],
                                          passive_verb=["matching #", "containing #", "saying #"],
                                          preposition=["about #"]
                                       }]
                                       #[string_values="tt:long_free_text"],

                                       out hashtags: Array(Entity(tt:hashtag))
                                       #_[canonical={
                                         base=["hashtags"],
                                         property=["hashtag #", "# hashtag"],
                                       }]
                                       #[string_values="com.twitter:hashtag"],

                                       out urls: Array(Entity(tt:url))
                                       #_[canonical="urls"],

                                       out author: Entity(tt:username)
                                       #_[prompt="from which user do you want tweets"]
                                       #_[canonical={
                                          base=["author", "user"],
                                          passive_verb=["authored by #", "written by #"],
                                          preposition=["from #", "by #"]
                                       }]
                                       #[string_values="com.twitter:username"],

                                       out from_self : Boolean
                                       #_[canonical={ preposition_true=["from me"], adjective_true=["my"] }],

                                       out in_reply_to: Entity(tt:username)
                                       #_[prompt="in reply to which user do you want tweets?"]
                                       #_[canonical={
                                          base=["mentioned user", "mention"],
                                          passive_verb=["replying to #"],
                                          verb=["reply to #"],
                                          preposition=["in reply to #"]
                                       }]
                                       #[string_values="com.twitter:username"]
                                       )
  #_[canonical=["my twitter home timeline", "tweet in my timeline", "tweet from anyone i follow", "tweet from people i follow"]]
  #_[result=["${author} tweeted : ${text}"]]
  #_[confirmation="tweets from anyone you follow"]
  #_[formatted=[{type="text",text="@${author} tweeted: ${text}"}]]
  #[poll_interval=600000ms]
  #[doc="shows your Twitter timeline (the home page of Twitter)"];

  monitorable list query direct_messages(out sender: Entity(tt:username)
                                         #_[canonical={
                                            base=["sender", "author", "user"],
                                            passive_verb=["written by #"],
                                            preposition=["from #", "by #"]
                                         }]
                                         #[string_values="com.twitter:username"],
                                         out message: String
                                         #_[canonical={
                                           base=["text", "message", "content"],
                                           verb=["contain #", "say #", "talk about #"],
                                           passive_verb=["matching #", "containing #", "saying #"],
                                           preposition=["about #"]
                                         }]
                                         #[string_values="tt:long_free_text"]
                                         )
  #_[canonical=["twitter direct messages",
                "twitter dms",
                "my twitter direct messages",
                "the direct messages i received on twitter",
                "the messages i got on twitter",
                "my twitter messages",
                "my twitter dms"]]
  #_[confirmation="direct messages you received on Twitter"]
  #_[formatted=[{type="text",text="@${sender}: ${message}"}]]
  #[poll_interval=600000ms]
  #[doc="get recent direct messages you received"];

  action send_direct_message(in req to: Entity(tt:username)
                             #_[prompt="who do you want to send the message to"]
                             #_[canonical={
                               base=["recipient"],
                               preposition=["to #"]
                             }]
                             #[string_values="com.twitter:username"],
                             in req message: String
                             #_[prompt="what message do you want to send"]
                             #_[canonical={
                               base=["message", "text", "content"],
                               preposition=["saying #"]
                             }]
                             #[string_values="tt:message"])
  #_[canonical="send dm on twitter"]
  #_[confirmation="send a direct message on Twitter to $to saying $message"]
  #[doc="send a direct message"];

  action post(in req status: String
              #_[prompt="what do you want to tweet"]
              #_[canonical={
                 base=["status", "text", "content"],
                 preposition=["saying #"]
              }]
              #[string_values="tt:long_free_text"]
              )
  #_[canonical=["tweet something",
                "make a tweet",
                "make a twitter post",
                "post on twitter"]]
  #_[confirmation="tweet $status"]
  #[doc="post a tweet; use # to include a hashtag and @ to reply"];

  action post_picture(in req caption: String
                      #_[canonical={
                         base=["caption", "message", "description"],
                         preposition=["saying #"]
                      }]
                      #[string_values="com.instagram:caption"],
                      in req picture_url: Entity(tt:picture)
                      #_[prompt="upload the picture now"]
                      #_[canonical={
                         base=["picture", "image", "photo"],
                      }])
  #_[canonical="post picture on twitter"]
  #_[confirmation="tweet $caption with an attached picture"]
  #[doc="post a tweet with a picture"];

  action follow(in req user_name: Entity(tt:username)
                #_[prompt=["what user do you want to follow", "who do you want to follow"]]
                #_[canonical={
                   base=["user name", "user", "account"],
                }]
                #[string_values="com.twitter:username"])
  #_[canonical="follow on twitter"]
  #_[confirmation="follow $user_name on Twitter"]
  #[doc="follow the named user"];

  action unfollow(in req user_name: Entity(tt:username)
                  #_[prompt=["what user do you want to follow", "who do you want to follow"]]
                  #_[canonical={
                     base=["user name", "user", "account"],
                  }]
                  #[string_values="com.twitter:username"])
  #_[canonical="unfollow on twitter"]
  #_[confirmation="unfollow $user_name on Twitter"]
  #[doc="stop following the named user; this call succeeds even if the user was already followed before"];

  action retweet(in req tweet_id: Entity(com.twitter:id) #_[prompt="What tweet do you want to retweet?"] #_[canonical="tweet id"])
  #_[canonical="retweet"]
  #_[confirmation="retween $tweet_id"]
  #_[confirmation_remote="retweet $tweet_id on $__person's Twitter Account"]
  #[doc="retweet a given tweet, by id"];
}

class @org.thingpedia.weather
#_[thingpedia_name="Weather"]
#_[thingpedia_description="Weather forecasts and information provided by met.no"]
#[license="BSD-3-Clause"]
#[license_gplcompatible=true]
#[subcategory="service"]
{
  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.none();

  monitorable query sunrise(in opt location: Location
                            #_[prompt="what location do you want sun time info for?"]
                            #_[canonical={
                              default="preposition",
                              base=["location", "position", "place"],
                              property=[],
                              preposition=["in #", "at #", "around #", "for location #", "for #"]
                            }]
                            #[default=$location.current_location],
                            in opt date: Date
                            #_[canonical={
                              default="preposition",
                              base=["date"],
                              preposition=["on #"]
                            }],
                            out sunrise_time: Time
                            #_[canonical="sunrise time"],
                            out sunset_time: Time
                            #_[canonical="sunset time"])
  #_[result=["in ${location} , the sun rises at ${sunrise_time} and sets at ${sunset_time}",
             "on ${date} the sun rises at ${sunrise_time} and sets at ${sunset_time} in ${location}",
             "on ${date} the sun rises at ${sunrise_time}",
             "on ${date} the sun sets at ${sunset_time}"]]
  #_[canonical=["sunrise and sunset time", "sunrise time", "sunset time"]]
  #_[confirmation="the sunrise and sunset time for location $location"]
  #_[formatted=[{type="text",text="Sun times on ${date:date} for ${location}: rises at ${sunrise_time}, sets at ${sunset_time}"}]]
  #[minimal_projection=["sunrise_time", "sunset_time"]]
  #[poll_interval=86400000ms]
  #[doc="Information about sunrise and sunset"];

  monitorable query moon(in opt location: Location
                         #_[prompt="what location do you want moon time info for"]
                         #_[canonical={
                            default="preposition",
                            base=["location", "position", "place"],
                            property=[],
                            preposition=["in #", "at #", "around #", "for location #", "for #"]
                         }]
                         #[default=$location.current_location],
                         in opt date: Date
                         #_[canonical={
                            default="preposition",
                            base=["date"],
                            preposition=["on #"]
                         }],
                         out phase: Enum(new_moon,waxing_crescent,first_quarter,waxing_gibbous,full_moon,waning_gibbous,third_quarter,waning_crescent)
                         #_[canonical=["phase", "moon phase"]]
                         )
  #_[result=["in ${location} the moon is ${phase}",
             "in ${location} the moon phase is ${phase}",
             "on ${date} the moon is ${phase} in ${location}",
             "the moon is ${phase}"]]
  #_[canonical=["moon phase", "phase of the moon"]]
  #_[confirmation="the moon phase for $location"]
  #_[formatted=[{type="text",text="Moon phase on ${date:date} for ${location}: ${phase}."}]]
  #[poll_interval=86400000ms]
  #[doc="Information about moon times and moon phase"]
  #[confirm=false];

  monitorable query current(in opt location: Location
                            #_[prompt="what location do you want the current weather for?"]
                            #_[canonical={
                              default="preposition",
                              base=["location", "position", "place"],
                              property=[],
                              preposition=["in #", "at #", "around #", "for location #", "for #"]
                            }]
                            #[default=$location.current_location],
                            out temperature: Measure(C)
                            #_[canonical="temperature"]
                            // from the coldest artic to the death valley, in one filter
                            #[min_number=-10C]
                            #[max_number=50C],
                            out wind_speed: Measure(mps)
                            #_[canonical="wind speed"]
                            #[min_number=0kmph]
                            #[max_number=150kmph],
                            out humidity: Number
                            #_[canonical="humidity"]
                            #[min_number=0]
                            #[max_number=100],
                            out cloudiness: Number
                            #_[canonical="cloudiness"]
                            #[min_number=0]
                            #[max_number=100],
                            out fog: Number
                            #_[canonical="fog"]
                            #[min_number=0]
                            #[max_number=100],
                            out status: Enum(raining,cloudy,sunny,snowy,sleety,drizzling,windy,foggy)
                            #_[canonical="status"],
                            out icon: Entity(tt:picture)
                            #_[canonical="icon"])
  #_[result=["the current weather in ${location} is ${status} . the temperature is ${temperature} and the humidity is ${humidity} % .",
             "the current weather in ${location} is ${status}",
             "the weather in ${location} is ${status}",
             "it is ${status} today in ${location} and the temperature is ${temperature}"]]
  #[minimal_projection=["status"]]
  #_[canonical=["current weather", "weather", "weather outside"]]
  #_[confirmation="the current weather for $location"]
  #_[formatted=[{type="text",text="Current weather for ${location}: ${status}, temperature ${temperature:C} C, wind speed ${wind_speed:mps} m/s, humidity ${humidity}%, cloudiness ${cloudiness}%, fog ${fog}%."}]]
  #[poll_interval=3600000ms]
  #[doc="Information about current weather"]
  #[confirm=false];

}

class @com.yelp
#_[name="Yelp"]
#_[description="Search restaurants on Yelp"]
#_[canonical="yelp"]
{
  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.none();

  entity restaurant #_[description="Restaurants on Yelp"];
  entity restaurant_cuisine #_[description="Cuisines in Yelp"];

  list query restaurant(out id: Entity(com.yelp:restaurant)
                        #[conflict_filter=["cuisines", "price_range"]]
                        #[unique=true]
                        #[string_values="gov.data:restaurant_names"]
                        #_[canonical={
                          default="base",
                          base=["name"],
                          property=[]
                        }],
                        out image_url: Entity(tt:picture)
                        #[filterable=false]
                        #_[canonical={
                          default="base",
                          base=["picture", "image", "photo"]
                        }],
                        out link: Entity(tt:url)
                        #[filterable=false]
                        #_[canonical="link"],
                        out cuisines: Array(Entity(com.yelp:restaurant_cuisine))
                        #[conflict_filter=["id"]]
                        #_[canonical={
                          default="property",
                          base=["cuisines", "types of cuisine", "food", "types of food", "category"],
                          property=["# food", "# cuisine", "# category"],
                          adjective=["#"],
                          verb=["serves # cuisine", "serves # food", "offer # cuisine", "offer # food", "serves", "offers"],
                          preposition=["in the # category"]
                        }],
                        out price : Enum(cheap, moderate, expensive, luxury)
                        #[conflict_filter=["id"]]
                        #_[canonical={
                          default="adjective",
                          base=["price range", "price"],
                          property=[],
                          adjective=["#", "# -ly priced"],
                          adjective_enum={ luxury=["upscale", "fine-dining"] }
                        }],
                        out rating: Number
                        #[min_number=1]
                        #[max_number=5]
                        #_[canonical={
                          default="passive_verb",
                          base=["rating", "average rating"],
                          passive_verb=["rated # star"],
                          adjective=["# star"],
                          property=["rating", "# star rating"]
                        }]
                        #_[counted_object="stars"],
                        out reviewCount: Number
                        #_[canonical={
                          default="property",
                          base=["review count"],
                          property=["# reviews"]
                        }]
                        #_[counted_object="reviews"],
                        out geo: Location
                        #_[canonical={
                          default="preposition",
                          base=["address", "location"],
                          preposition=["near #", "in #", "around #"]
                        }],
                        out phone: Entity(tt:phone_number)
                        #[filterable=false]
                        #_[canonical={
                          default="npp",
                          base=["telephone", "phone number"]
                        }])
  #_[canonical="restaurant"]
  #_[confirmation="restaurants on Yelp"]
  #[minimal_projection=["id"]]
  #_[formatted=[{
    type="rdl",
    displayTitle="${id}",
    webCallback="${link}",
    displayText="Offers ${cuisines} food.",
    pictureUrl="${image_url}"
  }]]
  #[doc="search for restaurants on Yelp"]
  #[confirm=false];
}

class @com.spotify
#_[thingpedia_name="Spotify"]
#_[thingpedia_description="Play music on Spotify"]
#_[canonical="spotify"]
#[license="BSD-3-Clause"]
#[license_gplcompatible=true]
#[subcategory="media"]
#_[name="Spotify Account of ${profile.display_name}"]
#_[description="This is your Spotify Account"]
{

  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.oauth2(
    client_id=$?, client_secret=$?,
    authorize="https://accounts.spotify.com/authorize"^^tt:url,
    get_access_token="https://accounts.spotify.com/api/token"^^tt:url,
    scope=["streaming", "playlist-read-collaborative", "playlist-modify-private", "playlist-read-private", "playlist-modify-public", "user-read-email", "user-read-private", "user-read-playback-state", "user-read-currently-playing", "user-modify-playback-state", "user-read-recently-played", "user-top-read", "user-follow-read", "user-follow-modify", "user-library-read", "user-library-modify"],
    get_profile="https://api.spotify.com/v1/me"^^tt:url,
    profile=["id", "display_name"]
  );

  entity song #_[description="Songs on Spotify"];
  entity artist #_[description="Artists on Spotify"];
  entity album #_[description="Albums on Spotify"];
  entity device #_[description="Spotify Connect device ID"];

  list query song(out id: Entity(com.spotify:song)
                    #[string_values="tt:song_name"]
                    #[unique=true]
                    #_[canonical={
                      default="base",
                      base=["name", "title", "track name"],
                      passive_verb=["named #", "called #", "titled #"],
                      property=["name #", "title #"]
                    }],
                    out artists: Array(Entity(com.spotify:artist))
                    #[string_values="tt:song_artist"]
                    #_[canonical={
                      default="preposition",
                      base=["artist", "author", "song writer", "band", "artist name",
                            "singer", "composer"],
                      property=["artist #", "song writer #"],
                      preposition=["by #", "from #"],
                      adjective=["#"],
                      passive_verb=["written by #", "released by #", "produced by #",
                                    "composed by #", "recorded by #"],
                      verb = ["# wrote", "# released", "# produced", "# composed",
                              "# did", "# recorded", "# sang", "# made"]
                    }],
                    out album: Entity(com.spotify:album)
                    #[string_values="tt:song_album"]
                    #_[canonical={
                      default="preposition",
                      base=["album"],
                      property=["album #"],
                      preposition=["in the album #",
                                   "in #", "part of #", "from the album #",
                                   "from #"],
                    }],
                    out genres: Array(String)
                    #[string_values="com.spotify:genre"]
                    #_[canonical={
                      default="adjective",
                      base=["genres", "type of genre", "type of music", "category"],
                      property=["# songs", "# music"],
                      adjective=["#"],
                      preposition=["in the # genre", "in #", "of the # genre",
                                   "in the # style", "in the # category"],
                    }],
                    out release_date : Date
                    #_[canonical={
                      default="passive_verb",
                      base=["date", "release date", "release year", "release day"],
                      property=["release date #"],
                      adjective=["#"],
                      preposition=["from #", "in #"],
                      passive_verb=["released on #", "released #", "published in #"],
                      adjective_argmin=["least recent", "oldest", "first"],
                      adjective_argmax=["most recent", "newest", "latest"],
                      passive_verb_argmax=["released most recently"],
                    }],
                    out popularity: Number
                    #[min_number=0]
                    #[max_number=100]
                    #_[canonical={
                      default="base",
                      base=["popularity", "average popularity"],
                      passive_verb=["rated # popularity"],
                      property=["# popularity"],
                      adjective_argmin=["least popular", "most niche"],
                      adjective_argmax=["most popular", "most well-known", "best", "greatest", "top"],
                    }],
                    out energy : Number
                    #[min_number=0]
                    #[max_number=100]
                    #[filterable=false]
                    #_[canonical={
                      default="base",
                      base=["energy"],
                      adjective_argmin=["least energetic"],
                      adjective_argmax=["most energetic"],
                    }],
                    out danceability : Number
                    #[min_number=0]
                    #[max_number=100]
                    #[filterable=false]
                    #_[canonical={
                      default="base",
                      base=["danceability"],
                      adjective_argmin=["least danceable"],
                      adjective_argmax=["most danceable"],
                    }])
    #_[canonical=["song", "music", "track"]]
    #_[confirmation="songs on Spotify"]
    #[minimal_projection=["id"]]
    #_[formatted=[{type="text",text="${id} by ${artists}"}]]
    #[doc="search for songs on Spotify"];

    action play_song (in req song: Entity(com.spotify:song)
                      #[string_values="tt:song_name"]
                      #_[prompt=["what song do you want to play"]]
                      #_[canonical={
                        default="base",
                        base=["name"],
                        // FIXME: actions must use "preposition" not "passive_verb"
                        preposition=["named #", "called #", "titled #"],
                        property=["name #", "title #"]
                      }],
                      out device : Entity(com.spotify:device)
                      #_[canonical={
                        default="preposition",
                        base=["device", "player", "app"], // "can you tell me the app"?
                        preposition=["on"]
                      }])
    #_[canonical=["play a song", "play the song", "play a track", "play music",
                  // i would like to...
                  "listen to a song", "hear a song"]]
    #_[confirmation="play the song $song"]
    #_[on_error={
      no_active_device=["you must open the spotify app first", "no spotify player is active"]
    }]
    #[confirm=enum(auto)];

    list query artist(out id: Entity(com.spotify:artist)
                      #[string_values="tt:song_artist"]
                      #[unique=true]
                      #_[canonical={
                        default="base",
                        base=["name"],
                        passive_verb=["named #", "called #"],
                        property=["name #"]
                      }],
                      out genres: Array(String)
                      #[string_values="com.spotify:genre"]
                      #_[canonical={
                        default="adjective",
                        base=["genres", "type of genre", "type of music", "category"],
                        property=["# songs", "# music"],
                        adjective=["#"],
                        preposition=["in the # genre", "in #", "of the # genre",
                                     "in the # style", "in the # category"],
                        verb=["plays # music", "plays the # genre", "does # music",
                              "plays # songs", "does the # genre",
                              "plays the # style", "belongs to the genre #",
                              "belongs to the # genre", "plays #"]
                      }],
                      out popularity: Number
                      #[min_number=0]
                      #[max_number=100]
                      #_[canonical={
                        default="base",
                        base=["popularity", "average popularity"],
                        passive_verb=["rated # popularity"],
                        property=["# popularity"],
                        adjective_argmin=["least popular", "most niche"],
                        adjective_argmax=["most popular", "most well-known", "best", "greatest", "top"],
                      }])
    #_[canonical=["artist", "composer", "musician", "singer"]]
    #_[confirmation="artists on Spotify"]
    #[minimal_projection=["id"]]
    #_[formatted=[{type="text",text="${id}"}]]
    #[doc="search for artists on Spotify"];

    list query album(out id: Entity(com.spotify:album) #[string_values="tt:song_album"]
                    #[unique=true]
                    #_[canonical={
                      default="base",
                      base=["name"],
                      passive_verb=["named #", "called #", "titled #"],
                      property=["name #", "title"]
                    }],
                    out artists: Array(Entity(com.spotify:artist))
                    #[string_values="tt:song_artist"]
                    #_[canonical={
                      default="preposition",
                      base=["artist", "author", "song writer", "band", "artist name",
                            "singer", "composer"],
                      property=["artist #", "song writer #"],
                      preposition=["by #", "from #"],
                      adjective=["#"],
                      passive_verb=["written by #", "released by #", "produced by #",
                                    "composed by #", "recorded by #"],
                      verb = ["# wrote", "# released", "# produced", "# composed",
                              "# did", "# recorded", "# sang", "# made"]
                    }],
                    out release_date : Date
                    #_[canonical={
                      default="preposition",
                      base=["date", "release date", "release year", "release day"],
                      property=["release date #"],
                      adjective=["#"],
                      preposition=["from #", "in #"],
                      passive_verb=["released in #", "released #", "published in #"],
                      adjective_argmin=["least recent", "oldest", "first"],
                      adjective_argmax=["most recent", "newest", "latest"],
                      passive_verb_argmax=["released most recently"],
                    }],
                    out popularity: Number
                    #[min_number=0]
                    #[max_number=100]
                    #_[canonical={
                      default="base",
                      base=["popularity", "average popularity"],
                      passive_verb=["rated # popularity"],
                      property=["# popularity"],
                      adjective_argmin=["least popular", "most niche"],
                      adjective_argmax=["most popular", "most well-known", "best", "greatest", "top"],
                    }])
    #_[canonical=["album", "music collection"]]
    #_[confirmation="album on Spotify"]
    #[minimal_projection=["id"]]
    #_[formatted=[{type="text",text="${id} by ${artists}"}]]
    #[doc="search for albums on Spotify"];

    monitorable query get_currently_playing(out song: Entity(com.spotify:song)
                                            #[string_values="tt:song_name"])
    #_[canonical=["the currently playing track name", "the currently playing song",
                  "the song currently playing"]]
    #_[confirmation="the currently playing track name"]
    #_[result=["currently playing ${song}", "the currently playing track is ${song}"]]
    #_[on_error={
      no_song_playing=["no song is currently playing", "nothing is currently playing"]
    }]
    #_[formatted=[{type="text",text="The current playing song is ${song}."}]]
    #[poll_interval=60000ms]
    #[doc="retrieve the currently playing track name"];

    monitorable list query get_user_top_tracks(out song: Entity(com.spotify:song)
                                               #[string_values="tt:song_name"])
    #_[canonical=["spotify top tracks", "my favorite songs",
                  "my top tracks"]]
    #_[confirmation="my top tracks in Spotify"]
    #_[formatted=[{type="text",text="${song}"}]]
    #[poll_interval=3600000ms]
    #[doc="get user's top tracks in the last 4 weeks"];

    action player_next()
    #_[canonical=["play the next song", "go to the next song", "skip this song"]]
    #_[confirmation="go to the next song"]
    #[doc="go to the next song"]
    #[confirm=false];

    action player_previous()
    #_[canonical=["play the previous song", "go back",
                  "play the last song",
                  "go back to the last song",
                  "go to the previous song"]]
    #_[confirmation="go to the previous song"]
    #[doc="go to the previous song"]
    #[confirm=false];

    action player_play()
    #_[canonical=["resume playing", "start playing again", "resume playback"]]
    #_[confirmation="resume playing"]
    #[doc="resume playback"]
    #[confirm=false];

    action player_pause()
    #_[canonical=["pause playback", "pause my spotify"]]
    #_[confirmation="pause playback"]
    #_[confirmation_remote="pause $_person's playback"]
    #[doc="pause playback"]
    #[confirm=false];

    action player_shuffle(in req shuffle: Enum(on,off)
                          #_[prompt="should we set the shuffle state to on or off"]
                          #_[canonical={
                            base=["shuffle"],
                            preposition=["to"]
                          }])
    #_[canonical="set the shuffle state"]
    #_[confirmation="set the shuffle state"]
    #_[confirmation_remote="set the shuffle state"]
    #[doc="set the shuffle state"]
    #[confirm=false];

    action player_repeat(in req repeat: Enum(track,context,off)
                         #_[prompt="should we set the repeat state to track, context, or off"]
                         #_[canonical={
                           base=["repeat"],
                           preposition=["to"]
                         }])
    #_[canonical="set the repeat state"]
    #_[confirmation="set the repeat state"]
    #_[confirmation_remote="set the repeat state"]
    #[doc="set the repeat state"]
    #[confirm=false];
}
class @com.icanhazdadjoke
#_[thingpedia_name="Dad Jokes"]
#_[thingpedia_description="Ask for a joke"]
#_[canonical="dad jokes"]
#[license="BSD-3-Clause"]
#[license_gplcompatible=true]
#[subcategory="service"]
{
  import loader from @org.thingpedia.generic_rest.v1();
  import config from @org.thingpedia.config.none();

  entity id #[has_ner=false];

  query get(out id: Entity(com.icanhazdadjoke:id)
            #[json_key="id"],
            out text: String
            #_[canonical={
               base=["text", "content"],
               verb=["say #"],
               passive_verb=["saying #"],
            }]
            #[json_key="joke"])
  #_[result=["${text}"]]
  #_[canonical=["joke", "dad joke", "funny joke"]]
  #_[confirmation="a dad joke"]
  #_[formatted=[{type="text",text="${text}"}]]
  #[doc="get a joke"]
  #[url="https://icanhazdadjoke.com/"];
}
class @com.thecatapi
#_[canonical="the cat api"] {
  entity image_id #[has_ner=false];

  query get(out id: Entity(com.thecatapi:image_id) #_[canonical="id"],
            out picture_url: Entity(tt:picture) #_[canonical="picture url"],
            out link: Entity(tt:url) #_[canonical="link"])
  #_[canonical="cat picture"]
  #_[confirmation="cat pictures"]
  #_[result=["here is your cat picture", "here is a cat picture for you"]]
  #_[formatted=[{type="rdl",webCallback="${link}",displayTitle="${link}",pictureUrl="${picture_url}"}]]
  #[confirm=false];
}
class @com.xkcd
#_[thingpedia_name="XKCD"]
#_[thingpedia_description="A webcomic of romance, sarcasm, math, and language."]
#[license="BSD-3-Clause"]
#[license_gplcompatible=true]
#[subcategory="media"]
{
  import loader from @org.thingpedia.v2();
  import config from @org.thingpedia.config.none();

  monitorable list query comic(out id: Number
                               #_[canonical={
                                 base=["number"],
                                 passive_verb=["number #"]
                               }],
                               out title: String
                               #_[canonical={
                                 base=["name", "title"],
                                 passive_verb=["titled #", "called #"]
                               }]
                               #[filterable=false]
                               #[string_values="com.xkcd:title"],
                               out release_date : Date
                               #_[canonical={
                                 base=["release date", "date"],
                                 passive_verb=["released on #"],
                                 preposition=["from #"],
                                 adjective=["# 's"],
                                 adjective_argmax=["latest", "most recent"],
                                 adjective_argmin=["earliest", "oldest"],
                               }],
                               out picture_url: Entity(tt:picture)
                               #_[canonical={
                                 base=["picture url", "image url"]
                               }],
                               out link: Entity(tt:url)
                               #_[canonical={
                                 base=["link", "url"]
                               }],
                               out alt_text: String
                               #_[canonical={
                                 base=["alt text", "alternate text"]
                               }]
                               #[filterable=false]
                               #[string_values="com.xkcd:alt_text"])
  #_[canonical=["xkcd comic", "xkcd"]]
  #_[confirmation="an Xkcd comic"]
  #_[result=["i found xkcd ${id}"]]
  #_[formatted=[{
     type="rdl",
     webCallback="${link}",
     displayTitle="${title}",
     pictureUrl="${picture_url}",
     displayText="${alt_text}"
  }]]
  #[minimal_projection=["id", "title"]]
  #[poll_interval=86400000ms]
  #[doc="retrieve the comic with a given number, or the latest comic"];

  query random_comic(out id: Number
                     #_[canonical={
                       base=["number"],
                       passive_verb=["number #"]
                     }],
                     out title: String
                     #_[canonical={
                       base=["name", "title"],
                       passive_verb=["titled #", "called #"]
                     }]
                     #[string_values="com.xkcd:title"],
                     out release_date : Date
                     #_[canonical={
                       base=["release date", "date"],
                       passive_verb=["released on #"],
                       preposition=["from #"]
                     }],
                     out picture_url: Entity(tt:picture)
                     #_[canonical={
                       base=["picture url", "image url"]
                     }],
                     out link: Entity(tt:url)
                     #_[canonical={
                       base=["link", "url"]
                     }],
                     out alt_text: String
                     #_[canonical={
                       base=["alt text", "alternate text"]
                     }]
                     #[string_values="com.xkcd:alt_text"])
  #_[canonical=["random xkcd",
                "random xkcd comic",
                "xkcd comic at random"]]
  #_[confirmation="a random Xkcd comic"]
  #_[result=["i found xkcd ${id}", "here is xkcd ${id}"]]
  #_[formatted=[{
     type="rdl",
     webCallback="${link}",
     displayTitle="${title}",
     pictureUrl="${picture_url}",
     displayText="${alt_text}"
  }]]
  #[minimal_projection=["id", "title"]]
  #[doc="retrieve a random xkcd"];
}
abstract class @org.thingpedia.iot.light-bulb extends @org.thingpedia.iot.switch
#_[name="Light Bulb"]
#_[description="The general interface supported by all light bulbs."]
#_[canonical="light bulb"]
{
  monitorable query power(out power : Enum(on, off)
                          #_[canonical="power"])
  #_[canonical="the power state of the light bulb"]
  #_[confirmation="the power state of ${__device}"]
  #_[result=["your lights are ${power}"]]
  #_[confirmation_remote="the power state of ${__device}"]
  #[minimal_projection=[]]
  #[confirm=false];

  action alert_long()
  #_[canonical="loop the color in my light bulb"]
  #_[confirmation="flash alerts on ${__device}"]
  #_[confirmation_remote="flash alerts on ${__device}"]
  #[confirm=true]
  #[minimal_projection=[]];

  action color_loop()
  #_[canonical="flash the lights"]
  #_[confirmation="loop colors on ${__device}"]
  #_[confirmation_remote="loop colors on ${__device}"]
  #[confirm=true]
  #[minimal_projection=[]];

  action set_power(in req power : Enum(on, off)
                   #_[prompt=["do you want to turn it on or off"]]
                   #_[canonical={
                     base=["power"],
                     property=[]
                   }])
  #_[canonical="set the power on the lights"]
  #_[confirmation="turn $power ${__device}"]
  #_[confirmation_remote="turn $power ${__device}"]
  #[confirm=true]
  #[minimal_projection=[]];
}
abstract class @org.thingpedia.iot.door
#_[description="Interface for Door Sensor."]
#_[name="Door Sensor"]
#_[canonical="door sensor"] {
  monitorable query state(out state : Enum(open, closed)
                          #_[canonical="state"])
  #_[canonical="door state"]
  #_[confirmation="the state of $__device"]
  #_[result=["the entrance is ${state}"]]
  #_[confirmation_remote="the state of $__device"]
  #[minimal_projection=[]]
  #[confirm=false];
}
