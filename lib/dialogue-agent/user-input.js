// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
"use strict";

const ThingTalk = require('thingtalk');
const Ast = ThingTalk.Ast;

const ValueCategory = require('./value-category');

function parseSpecial(thingtalk, context) {
    switch (thingtalk.intent.type) {
    case 'yes':
        return new Answer(new Ast.Value.Boolean(true), context.platformData);
    case 'no':
        return new Answer(new Ast.Value.Boolean(false), context.platformData);
    default:
        return new UICommand(thingtalk.intent.type, context.platformData);
    }
}

/**
 * Base class for the interpretation of the input from the user, which could be
 * a UI action (a button) or a natural language command.
 */
class UserInput {
    constructor(platformData) {
        this.platformData = platformData;
    }

    static fromThingTalk(thingtalk, context) {
        if (thingtalk.isBookkeeping) {
            if (thingtalk.intent.isSpecial)
                return parseSpecial(thingtalk, context);
            else if (thingtalk.intent.isAnswer)
                return new Answer(thingtalk.intent.value, context.platformData);
            else if (thingtalk.intent.isChoice)
                return new MultipleChoiceAnswer(thingtalk.intent.value, context.platformData);
            else
                throw new TypeError(`Unrecognized bookkeeping intent`);
        } else if (thingtalk.isProgram) {
            return new Program(thingtalk, context.platformData);
        } else if (thingtalk.isDialogueState) {
            return new DialogueState(thingtalk, context.platformData);
        } else {
            throw new TypeError(`Unrecognized ThingTalk command: ${thingtalk.prettyprint()}`);
        }
    }

    static async parse(json, schemaRetriever, context) {
        if ('program' in json)
            return UserInput.fromThingTalk(await ThingTalk.Grammar.parseAndTypecheck(json.program, schemaRetriever, true), context);

        let { code, entities } = json;
        for (let name in entities) {
            if (name.startsWith('SLOT_')) {
                let slotname = json.slots[parseInt(name.substring('SLOT_'.length))];
                let slotType = ThingTalk.Type.fromString(json.slotTypes[slotname]);
                let value = Ast.Value.fromJSON(slotType, entities[name]);
                entities[name] = value;
            }
        }

        const thingtalk = ThingTalk.NNSyntax.fromNN(code, entities);
        await thingtalk.typecheck(schemaRetriever, true);
        return UserInput.fromThingTalk(thingtalk, context);
    }

    static async parseThingTalk(code, schemaRetriever, context) {
        return UserInput.fromThingTalk(await ThingTalk.Grammar.parseAndTypecheck(code, schemaRetriever, true), context);
    }
}
module.exports = UserInput;

/**
 * A natural language command that was parsed correctly but is not supported in
 * Thingpedia (it uses Thingpedia classes that are not available).
 */
class UnsupportedCommand extends UserInput {}
UserInput.Unsupported = UnsupportedCommand;
UnsupportedCommand.prototype.isUnsupported = true;

/**
 * A natural language command that failed to parse entirely.
 */
class FailedCommand extends UserInput {
    constructor(utterance, platformData) {
        super(platformData);
        this.utterance = utterance;
    }
}
UserInput.Failed = FailedCommand;
FailedCommand.prototype.isFailed = true;

/**
 * A special command that bypasses the neural network, or a button on the UI.
 */
class UICommand extends UserInput {
    constructor(type, platformData) {
        super(platformData);
        this.type = type;
    }
}
UserInput.UICommand = UICommand;
UICommand.prototype.isUICommand = true;

/**
 * A multiple choice answer. This can be generated by the UI button,
 * or by the parser in multiple choice mode. It is only used to disambiguate
 * entities and device names
 */
class MultipleChoiceAnswer extends UserInput {
    constructor(value, platformData) {
        super(platformData);
        this.value = value;
        this.category = ValueCategory.MultipleChoice;
    }
}
UserInput.MultipleChoiceAnswer = MultipleChoiceAnswer;
MultipleChoiceAnswer.prototype.isMultipleChoiceAnswer = true;

/**
 * A single, naked ThingTalk value. This can be generated by the UI pickers
 * (file pickers, location pickers, contact pickers, etc.), in certain uses
 * of the exact matcher, and when the agent is in raw mode.
 */
class Answer extends UserInput {
    constructor(value, platformData) {
        super(platformData);
        this.value = value;
        this.category = ValueCategory.fromValue(value);
    }
}
UserInput.Answer = Answer;
Answer.prototype.isAnswer = true;

/**
 * A single ThingTalk program. This can come from a single-command neural network,
 * or from the user typing "\t".
 */
class Program extends UserInput {
    constructor(program, platformData) {
        super(platformData);
        this.program = program;
    }
}
UserInput.Program = Program;
Program.prototype.isProgram = true;

/**
 * A prediction ThingTalk dialogue state (policy, dialogue act, statements), which
 * is generated by the neural network after parsing the user's input.
 */
class DialogueState extends UserInput {
    constructor(prediction, platformData) {
        super(platformData);
        this.prediction = prediction;
    }
}
UserInput.DialogueState = DialogueState;
DialogueState.prototype.isDialogueState = true;
